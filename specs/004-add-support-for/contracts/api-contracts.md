# API Contracts: PKCE Support for OpenID Connect Authentication

**Feature**: PKCE Support  
**Date**: 2025-10-20

## Overview

This document defines the API changes required to support PKCE in the existing authentication flow. Most changes are internal to provider implementations and frontend utilities. The main HTTP API endpoints remain unchanged, with PKCE parameters added as optional extensions.

## Modified Backend Endpoints

### 1. GET /api/auth/login

**Purpose**: Initiate OAuth login flow with PKCE support

**Changes**: Query parameters extended to accept PKCE challenge (generated by frontend)

**Request**:
```http
GET /api/auth/login?code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&code_challenge_method=S256 HTTP/1.1
Host: localhost:3000
```

**Query Parameters**:
```typescript
{
  code_challenge?: string;        // Base64URL-encoded SHA256 hash (optional for backward compatibility)
  code_challenge_method?: 'S256'; // Always S256 when code_challenge provided
  // Existing parameters remain unchanged
}
```

**Response**: 302 Redirect to OAuth provider
```http
HTTP/1.1 302 Found
Location: https://provider.com/authorize?
  client_id=xxx&
  redirect_uri=http://localhost:3000/api/auth/callback&
  response_type=code&
  scope=openid+profile+email&
  state=random_uuid&
  code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&
  code_challenge_method=S256
```

**Backward Compatibility**: If `code_challenge` not provided, flow continues without PKCE (for transition period)

---

### 2. GET /api/auth/callback

**Purpose**: Handle OAuth callback and exchange authorization code for tokens with PKCE verification

**Changes**: Query/body parameters extended to accept code_verifier

**Request**:
```http
GET /api/auth/callback?code=auth_code_123&state=random_uuid HTTP/1.1
Host: localhost:3000
Content-Type: application/json

{
  "code_verifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
}
```

**Query Parameters**:
```typescript
{
  code: string;        // Authorization code from provider
  state: string;       // OAuth state for CSRF protection
  // Existing parameters
}
```

**Body Parameters** (NEW):
```typescript
{
  code_verifier?: string; // Original PKCE verifier (43-128 characters, base64url-encoded)
}
```

**Success Response**: 200 OK
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "refresh_token": "eyJhbGciOiJSUzI1NiIs...",
  "expires_in": 3600,
  "token_type": "Bearer"
}
```

**Error Response - Missing Verifier**: 400 Bad Request
```json
{
  "error": "invalid_request",
  "error_description": "PKCE code_verifier is required but was not provided"
}
```

**Error Response - Invalid Verifier**: 400 Bad Request
```json
{
  "error": "invalid_grant",
  "error_description": "PKCE validation failed: code_verifier does not match code_challenge"
}
```

---

## Frontend API (No HTTP Endpoints)

### PKCE Utility Functions

**File**: `frontend/src/utils/pkce.ts`

#### generateCodeVerifier()

**Purpose**: Generate cryptographically random code_verifier

**Signature**:
```typescript
function generateCodeVerifier(): string
```

**Returns**: Base64URL-encoded string, 43-128 characters

**Example**:
```typescript
const verifier = generateCodeVerifier();
// "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
```

---

#### generateCodeChallenge()

**Purpose**: Derive code_challenge from code_verifier using SHA256

**Signature**:
```typescript
async function generateCodeChallenge(codeVerifier: string): Promise<string>
```

**Parameters**:
- `codeVerifier`: Base64URL-encoded string (43-128 characters)

**Returns**: Base64URL-encoded SHA256 hash

**Example**:
```typescript
const challenge = await generateCodeChallenge(verifier);
// "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
```

---

#### storePKCEVerifier()

**Purpose**: Store code_verifier in sessionStorage linked to OAuth state

**Signature**:
```typescript
function storePKCEVerifier(state: string, codeVerifier: string): void
```

**Parameters**:
- `state`: OAuth state parameter (UUID)
- `codeVerifier`: Generated verifier

**Storage Key**: `pkce_verifier_${state}`

**Storage Value**:
```json
{
  "codeVerifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk",
  "createdAt": 1698765432000,
  "expiresAt": 1698765732000
}
```

---

#### retrievePKCEVerifier()

**Purpose**: Retrieve code_verifier from sessionStorage using OAuth state

**Signature**:
```typescript
function retrievePKCEVerifier(state: string): string | null
```

**Parameters**:
- `state`: OAuth state parameter from callback

**Returns**: code_verifier string or null if not found/expired

**Side Effects**: Removes entry from sessionStorage after retrieval

---

#### cleanupPKCEVerifier()

**Purpose**: Remove specific PKCE verifier from storage

**Signature**:
```typescript
function cleanupPKCEVerifier(state: string): void
```

**Parameters**:
- `state`: OAuth state parameter

---

## Backend Provider Interface Changes

### IAuthProvider Interface

**File**: `backend/src/infrastructure/external/IAuthProvider.ts`

#### Modified: getAuthorizationUrl()

**Before**:
```typescript
getAuthorizationUrl(redirectUri: string, state?: string): string
```

**After**:
```typescript
getAuthorizationUrl(
  redirectUri: string, 
  state?: string,
  pkceParams?: { 
    codeChallenge: string; 
    codeChallengeMethod: 'S256' 
  }
): string
```

**Parameters**:
- `redirectUri`: OAuth callback URL
- `state`: CSRF protection token (optional)
- `pkceParams`: PKCE parameters (optional for backward compatibility)
  - `codeChallenge`: Base64URL-encoded SHA256 hash
  - `codeChallengeMethod`: Always 'S256'

**Returns**: Authorization URL with PKCE parameters appended

---

#### Modified: authenticateWithCode()

**Before**:
```typescript
authenticateWithCode(code: string, redirectUri: string): Promise<{
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
}>
```

**After**:
```typescript
authenticateWithCode(
  code: string, 
  redirectUri: string,
  codeVerifier?: string
): Promise<{
  accessToken: string;
  refreshToken?: string;
  expiresIn: number;
}>
```

**Parameters**:
- `code`: Authorization code from provider
- `redirectUri`: Same URI used in authorization request
- `codeVerifier`: PKCE verifier (optional for backward compatibility)

**Returns**: Token response

**Throws**: `PKCEValidationError` if verifier validation fails

---

## Provider-Specific Token Exchange Requests

### Keycloak Token Exchange

**Endpoint**: `POST https://keycloak.example.com/realms/{realm}/protocol/openid-connect/token`

**Request with PKCE**:
```http
POST /realms/movietrack/protocol/openid-connect/token HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code=auth_code_123&
redirect_uri=http://localhost:3000/api/auth/callback&
client_id=movietrack-app&
client_secret=xxx&
code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
```

**New Parameter**:
- `code_verifier`: Original PKCE verifier (required when code_challenge was used)

---

### WorkOS Token Exchange

**Endpoint**: `POST https://api.workos.com/sso/token`

**Request with PKCE**:
```http
POST /sso/token HTTP/1.1
Host: api.workos.com
Content-Type: application/json
Authorization: Bearer sk_workos_api_key

{
  "code": "auth_code_123",
  "client_id": "client_xxx",
  "code_verifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
}
```

**New Parameter**:
- `code_verifier`: Original PKCE verifier

---

### Mock Provider Token Exchange (Local Testing)

**Endpoint**: `POST /api/auth/mock/token` (in-process, not HTTP)

**Interface**:
```typescript
interface MockTokenRequest {
  code: string;
  code_verifier?: string;
}

interface MockTokenResponse {
  access_token: string;
  token_type: 'Bearer';
  expires_in: number;
}
```

**Validation Logic**:
```typescript
// Mock provider validates PKCE
function validatePKCE(code: string, codeVerifier: string): boolean {
  const storedChallenge = mockPKCEStore.get(code);
  if (!storedChallenge) return false;
  
  const computedChallenge = base64UrlEncode(
    await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier))
  );
  
  return computedChallenge === storedChallenge.codeChallenge;
}
```

---

## Error Codes and Messages

### PKCE-Specific Errors

| Error Code | HTTP Status | Description | User Message |
|------------|-------------|-------------|--------------|
| `pkce_verifier_missing` | 400 | code_verifier not provided when required | "Authentication failed. Please try logging in again." |
| `pkce_verifier_invalid` | 400 | code_verifier format invalid (wrong length/encoding) | "Authentication failed. Please try logging in again." |
| `pkce_validation_failed` | 400 | code_verifier doesn't match code_challenge | "Security verification failed. Please retry login." |
| `pkce_challenge_missing` | 400 | code_challenge not provided when PKCE enforced | "Authentication configuration error. Contact support." |
| `pkce_storage_failed` | 500 | Failed to store/retrieve verifier from sessionStorage | "Authentication failed. Please enable cookies and retry." |

### Logging Format

**Security Event Log**:
```json
{
  "timestamp": "2025-10-20T10:30:45.123Z",
  "level": "warn",
  "event": "pkce_validation_failed",
  "correlation_id": "req-abc-123",
  "user_id": "user-xyz",
  "provider": "keycloak",
  "details": {
    "error_code": "pkce_validation_failed",
    "verifier_provided": true,
    "challenge_matched": false
  }
}
```

**Performance Metric Log**:
```json
{
  "timestamp": "2025-10-20T10:30:45.123Z",
  "level": "info",
  "event": "pkce_flow_completed",
  "correlation_id": "req-abc-123",
  "metrics": {
    "verifier_generation_ms": 8,
    "challenge_generation_ms": 4,
    "total_pkce_overhead_ms": 12,
    "total_auth_flow_ms": 1450
  }
}
```

---

## Testing Contracts

### Test Scenarios

#### 1. Valid PKCE Flow

**Given**: User initiates login with PKCE
**When**: Authorization completes with correct code_verifier
**Then**: Token exchange succeeds

**Test Request**:
```typescript
const verifier = generateCodeVerifier();
const challenge = await generateCodeChallenge(verifier);

// Step 1: Login
GET /api/auth/login?code_challenge=${challenge}&code_challenge_method=S256

// Step 2: Callback (after provider redirect)
POST /api/auth/callback?code=xyz&state=abc
Body: { code_verifier: verifier }

// Expected: 200 OK with tokens
```

---

#### 2. Missing code_verifier

**Given**: PKCE flow initiated with code_challenge
**When**: Callback doesn't include code_verifier
**Then**: Returns 400 Bad Request

**Test Request**:
```typescript
POST /api/auth/callback?code=xyz&state=abc
Body: {}

// Expected: 400 Bad Request
// { "error": "invalid_request", "error_description": "..." }
```

---

#### 3. Invalid code_verifier

**Given**: PKCE flow initiated
**When**: Callback includes wrong code_verifier
**Then**: Returns 400 Bad Request

**Test Request**:
```typescript
POST /api/auth/callback?code=xyz&state=abc
Body: { code_verifier: "wrong_verifier_value_that_doesnt_match" }

// Expected: 400 Bad Request
// { "error": "invalid_grant", "error_description": "..." }
```

---

## Migration Strategy

### Phase 1: Optional PKCE (Week 1)

- PKCE parameters optional in all endpoints
- Frontend generates PKCE for new auth flows
- Backend accepts both PKCE and non-PKCE flows
- Monitor PKCE adoption rate

### Phase 2: PKCE Required (Week 2+)

- After 100% of flows using PKCE
- Make PKCE parameters required
- Reject non-PKCE flows
- Update error messages

---

## Backward Compatibility

All API changes are **backward compatible**:

✅ Optional parameters (code_challenge, code_verifier)
✅ Existing flows work without PKCE during transition
✅ No breaking changes to request/response formats
✅ Gradual rollout supported

## Summary

- **Modified Endpoints**: 2 (GET /api/auth/login, GET /api/auth/callback)
- **New Utility Functions**: 5 (PKCE generation, storage, retrieval)
- **Modified Interfaces**: 1 (IAuthProvider)
- **New Error Codes**: 5
- **Database Changes**: None
- **Breaking Changes**: None (all optional parameters)
