# Data Model

**Feature**: Multi-User Movie & Series Tracking Application  
**Date**: 2025-10-15  
**Status**: Phase 1 - Design Complete

## Entity Relationship Overview

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│    User     │         │   Entry     │         │   Rating    │
├─────────────┤         ├─────────────┤         ├─────────────┤
│ id (PK)     │────────>│ creator_id  │<────────│ entry_id    │
│ oauth_subj  │         │ title (UNQ) │         │ user_id     │
│ email       │         │ platform_id │         │ stars       │
│ name        │         │ created_at  │         │ created_at  │
│ is_admin    │         │ updated_at  │         │ updated_at  │
│ last_login  │         └─────────────┘         └─────────────┘
│ created_at  │                 │                       
└─────────────┘                 │                       
                                │                       
                        ┌───────┴───────┐               
                        │               │               
                ┌───────v─────┐ ┌──────v──────┐        
                │ Entry_Tags  │ │ Streaming   │        
                ├─────────────┤ │ Platform    │        
                │ entry_id    │ ├─────────────┤        
                │ tag_id      │ │ id (PK)     │        
                └─────────────┘ │ name (UNQ)  │        
                        │       └─────────────┘        
                        │                              
                ┌───────v─────┐                        
                │ Genre_Tag   │                        
                ├─────────────┤                        
                │ id (PK)     │                        
                │ name (UNQ)  │                        
                └─────────────┘                        
```

## Domain Entities

### User

Represents authenticated users with OAuth2 identity and role-based permissions.

**Fields**:

- `id` (UUID, PK): Unique identifier generated by `crypto.randomUUID()`
- `oauth_subject` (string, unique, not null): OAuth2 subject identifier from WorkOS
- `email` (string, not null): User's email address
- `name` (string, not null): User's display name
- `is_admin` (boolean, default false): Admin role flag for platform/tag management
- `last_login` (timestamp, nullable): Last successful login timestamp
- `created_at` (timestamp, not null): Account creation timestamp

**Business Rules**:

- OAuth subject must be unique across all users
- Admin users can manage streaming platforms and genre tags
- When user is deleted, entries and ratings are preserved (see Entry.creator_id handling)

**Validation Rules**:

- Email must be valid email format
- Name must be 1-100 characters
- OAuth subject must not be empty

**Domain Methods** (if applicable):

```typescript
class User {
  updateLastLogin(): void
  isAdmin(): boolean
  anonymize(): void  // For account deletion
}
```

---

### Entry

Represents a movie or series with metadata, tags, and optional streaming platform.

**Fields**:

- `id` (UUID, PK): Unique identifier generated by `crypto.randomUUID()`
- `title` (string, unique, not null): Movie/series title (unique constraint enforces FR-003)
- `media_type` (enum, not null): Type of media - 'film' or 'series'
- `creator_id` (UUID, FK to User, nullable): User who created the entry (NULL or sentinel for deleted users)
- `platform_id` (UUID, FK to StreamingPlatform, nullable): Associated streaming platform
- `average_rating` (decimal, nullable): Cached average rating (updated when ratings change for performance)
- `created_at` (timestamp, not null): Entry creation timestamp
- `updated_at` (timestamp, not null): Last update timestamp

**Relationships**:

- Many-to-Many with GenreTag through Entry_Tags junction table (max 3 tags enforced at application layer)
- Many-to-One with StreamingPlatform (optional)
- One-to-Many with Rating
- Many-to-One with User (creator)

**Business Rules**:

- Title must be unique across all entries (enforced by database constraint)
- Must have 1-3 genre tags (enforced at application layer via Zod validation)
- Streaming platform is optional
- Last-write-wins for concurrent updates (no optimistic locking)
- When creator user is deleted, `creator_id` becomes NULL or references sentinel "Deleted User"
- Average rating is cached in `average_rating` column and updated whenever ratings are added/updated/deleted for performance

**Validation Rules**:

- Title must be 1-200 characters
- Title must be unique (case-sensitive)
- Media type must be either 'film' or 'series'
- Must have at least 1 genre tag
- Must have at most 3 genre tags

**Domain Methods**:

```typescript
class Entry {
  updateTitle(newTitle: string): void
  updateMediaType(mediaType: 'film' | 'series'): void
  updateTags(tags: GenreTag[]): void  // Enforces 1-3 constraint
  assignPlatform(platform: StreamingPlatform | null): void
  updateAverageRating(newAverage: number | null): void  // Updates cached average_rating
  getAverageRating(): number | null  // Returns cached value
}
```

---

### Rating

Represents a user's personal rating for a specific entry (1-10 whole number stars).

**Fields**:

- `user_id` (UUID, FK to User, PK composite): User who created the rating
- `entry_id` (UUID, FK to Entry, PK composite): Entry being rated
- `stars` (integer, not null): Rating value (1-10 inclusive)
- `created_at` (timestamp, not null): Rating creation timestamp
- `updated_at` (timestamp, not null): Last update timestamp

**Relationships**:

- Many-to-One with User
- Many-to-One with Entry
- Composite primary key: (user_id, entry_id) ensures one rating per user per entry

**Business Rules**:

- Each user can have only one rating per entry (enforced by composite PK)
- Rating values are whole numbers only (1-10 integers)
- Users can update their existing ratings (last-write-wins)
- Ratings are preserved when user is anonymized (user_id remains but user is "Deleted User")

**Validation Rules**:

- Stars must be integer between 1 and 10 inclusive
- User must exist
- Entry must exist

**Domain Methods**:

```typescript
class Rating {
  updateStars(newStars: number): void  // Validates 1-10 range
  isValid(): boolean
}
```

---

### StreamingPlatform

Represents available streaming services for content categorization. Managed by admin users.

**Fields**:

- `id` (UUID, PK): Unique identifier generated by `crypto.randomUUID()`
- `name` (string, unique, not null): Platform name (e.g., "Netflix", "Disney+")

**Relationships**:

- One-to-Many with Entry

**Business Rules**:

- Admin-only: Only admin users can create or delete platforms (enforced at application layer)
- Cannot delete platform if in use by any entry (enforced by foreign key constraint or application check)
- Platform names must be unique

**Validation Rules**:

- Name must be 1-50 characters
- Name must be unique

**Domain Methods**:

```typescript
class StreamingPlatform {
  isInUse(entries: Entry[]): boolean  // Check before deletion
}
```

---

### GenreTag

Represents available genre categories for content tagging. Managed by admin users.

**Fields**:

- `id` (UUID, PK): Unique identifier generated by `crypto.randomUUID()`
- `name` (string, unique, not null): Genre name (e.g., "Action", "Comedy", "Drama")

**Relationships**:

- Many-to-Many with Entry through Entry_Tags junction table

**Business Rules**:

- Admin-only: Only admin users can create or delete tags (enforced at application layer)
- Cannot delete tag if in use by any entry (enforced by checking Entry_Tags table)
- Tag names must be unique
- Each entry must have 1-3 tags (enforced at application layer)

**Validation Rules**:

- Name must be 1-30 characters
- Name must be unique

**Domain Methods**:

```typescript
class GenreTag {
  isInUse(entryTags: EntryTag[]): boolean  // Check before deletion
}
```

---

### Entry_Tags (Junction Table)

Represents the many-to-many relationship between entries and genre tags.

**Fields**:

- `entry_id` (UUID, FK to Entry, PK composite): Entry reference
- `tag_id` (UUID, FK to GenreTag, PK composite): Tag reference

**Relationships**:

- Many-to-One with Entry
- Many-to-One with GenreTag
- Composite primary key: (entry_id, tag_id)

**Business Rules**:

- Each entry can have 1-3 tags (enforced at application layer via validation)
- Same tag cannot be assigned to same entry multiple times (enforced by composite PK)
- When tag is deleted and in use, deletion must be blocked (application layer check)

**Database Constraints**:

- Composite primary key on (entry_id, tag_id)
- Foreign key to entries(id) ON DELETE CASCADE
- Foreign key to genre_tags(id) ON DELETE RESTRICT

## Value Objects

### EntryFilters

Encapsulates filtering criteria for entry queries (not a database entity).

**Fields**:

- `tagIds` (UUID[], optional): Filter by genre tag IDs
- `mediaType` (enum, optional): Filter by media type ('film' or 'series')
- `newToMe` (boolean, optional): Filter entries created/updated since user's last login
- `userId` (UUID, optional): User ID for "new to me" filter context
- `page` (number, default 1): Pagination page number
- `pageSize` (number, default 10): Items per page

**Business Rules**:

- Page must be >= 1
- Page size must be 10 (fixed per spec requirement FR-006)
- When `newToMe` is true, `userId` must be provided
- Media type, if provided, must be either 'film' or 'series'

**Validation Rules**:

```typescript
const EntryFiltersSchema = z.object({
  tagIds: z.array(z.string().uuid()).optional(),
  mediaType: z.enum(['film', 'series']).optional(),
  newToMe: z.boolean().optional(),
  userId: z.string().uuid().optional(),
  page: z.number().int().min(1).default(1),
  pageSize: z.number().int().default(10)
});
```

## State Transitions

### Entry Lifecycle

```
[Created] ──(user updates title/tags)──> [Updated]
    │
    └──(user deletes creator account)──> [Creator Anonymized]
```

### Rating Lifecycle

```
[Created] ──(user updates stars)──> [Updated]
```

### User Lifecycle

```
[Created] ──(user logs in)──> [Active] ──(account deleted)──> [Anonymized]
                                                                    │
                                                                    └──> Entries/Ratings preserved
                                                                         with "Deleted User"
```

## Aggregates

Following DDD principles, the following aggregates are identified:

### Entry Aggregate

**Aggregate Root**: Entry  
**Entities**: Entry, Rating (as part of entry details view)  
**Value Objects**: EntryFilters

**Invariants**:

- Entry must have 1-3 genre tags
- Entry title must be unique
- Average rating calculation is derived from all ratings for the entry

**Repository**: IEntryRepository

### User Aggregate

**Aggregate Root**: User  
**Entities**: User, Rating (user's ratings)

**Invariants**:

- User must have unique OAuth subject
- User can have only one rating per entry

**Repository**: IUserRepository, IRatingRepository

### Admin Management Aggregates

**StreamingPlatform Aggregate**:

- Simple aggregate with single entity
- Repository: IStreamingPlatformRepository

**GenreTag Aggregate**:

- Simple aggregate with single entity
- Repository: IGenreTagRepository

## Database Schema (PostgreSQL)

```sql
-- Users table
CREATE TABLE users (
  id UUID PRIMARY KEY,
  oauth_subject VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) NOT NULL,
  name VARCHAR(100) NOT NULL,
  is_admin BOOLEAN DEFAULT FALSE,
  last_login TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_oauth_subject ON users(oauth_subject);
CREATE INDEX idx_users_email ON users(email);

-- Streaming platforms table
CREATE TABLE streaming_platforms (
  id UUID PRIMARY KEY,
  name VARCHAR(50) UNIQUE NOT NULL
);

-- Genre tags table
CREATE TABLE genre_tags (
  id UUID PRIMARY KEY,
  name VARCHAR(30) UNIQUE NOT NULL
);

-- Entries table
CREATE TABLE entries (
  id UUID PRIMARY KEY,
  title VARCHAR(200) UNIQUE NOT NULL,
  media_type VARCHAR(10) NOT NULL CHECK (media_type IN ('film', 'series')),
  creator_id UUID REFERENCES users(id) ON DELETE SET NULL,
  platform_id UUID REFERENCES streaming_platforms(id) ON DELETE SET NULL,
  average_rating DECIMAL(3,2),
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_entries_title ON entries(title);
CREATE INDEX idx_entries_media_type ON entries(media_type);
CREATE INDEX idx_entries_created_at ON entries(created_at DESC);
CREATE INDEX idx_entries_creator_id ON entries(creator_id);
CREATE INDEX idx_entries_average_rating ON entries(average_rating DESC);

-- Entry tags junction table
CREATE TABLE entry_tags (
  entry_id UUID REFERENCES entries(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES genre_tags(id) ON DELETE RESTRICT,
  PRIMARY KEY (entry_id, tag_id)
);

CREATE INDEX idx_entry_tags_tag_id ON entry_tags(tag_id);

-- Ratings table
CREATE TABLE ratings (
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  entry_id UUID REFERENCES entries(id) ON DELETE CASCADE,
  stars INTEGER NOT NULL CHECK (stars >= 1 AND stars <= 10),
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, entry_id)
);

CREATE INDEX idx_ratings_entry_id ON ratings(entry_id);
CREATE INDEX idx_ratings_user_id ON ratings(user_id);
```

## Repository Interfaces

Repository interfaces are defined in the Domain layer and implemented in the Infrastructure layer.

### IUserRepository

```typescript
interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findByOAuthSubject(subject: string): Promise<User | null>;
  create(user: User): Promise<void>;
  update(user: User): Promise<void>;
  delete(id: string): Promise<void>;  // Triggers anonymization
}
```

### IEntryRepository

```typescript
interface IEntryRepository {
  findById(id: string): Promise<Entry | null>;
  findByTitle(title: string): Promise<Entry | null>;
  findAll(filters: EntryFilters): Promise<{ entries: Entry[], total: number }>;
  create(entry: Entry, tagIds: string[]): Promise<void>;
  update(entry: Entry, tagIds: string[]): Promise<void>;
  delete(id: string): Promise<void>;
}
```

### IRatingRepository

```typescript
interface IRatingRepository {
  findByUserAndEntry(userId: string, entryId: string): Promise<Rating | null>;
  findByEntry(entryId: string): Promise<Rating[]>;
  findByUser(userId: string): Promise<Rating[]>;
  create(rating: Rating): Promise<void>;
  update(rating: Rating): Promise<void>;
  calculateAverageRating(entryId: string): Promise<number | null>;
}
```

### IStreamingPlatformRepository

```typescript
interface IStreamingPlatformRepository {
  findById(id: string): Promise<StreamingPlatform | null>;
  findAll(): Promise<StreamingPlatform[]>;
  create(platform: StreamingPlatform): Promise<void>;
  delete(id: string): Promise<void>;  // Throws error if in use
  isInUse(id: string): Promise<boolean>;
}
```

### IGenreTagRepository

```typescript
interface IGenreTagRepository {
  findById(id: string): Promise<GenreTag | null>;
  findAll(): Promise<GenreTag[]>;
  create(tag: GenreTag): Promise<void>;
  delete(id: string): Promise<void>;  // Throws error if in use
  isInUse(id: string): Promise<boolean>;
}
```

## Migration Strategy

Database migrations will be managed using SQL migration files in `backend/src/infrastructure/persistence/migrations/`.

**Migration Files**:

1. `001_initial_schema.sql`: Creates all tables with constraints and indexes
2. `002_seed_data.sql`: Seeds initial admin user, sample platforms, and genre tags (for development)

**Migration Execution**:

- Migrations run on application startup in development mode
- Production migrations run via CI/CD pipeline before deployment
- Use simple migration runner (e.g., `node-pg-migrate` or custom script)

## Data Integrity Constraints

### Unique Constraints

- `users.oauth_subject` (UNIQUE)
- `users.email` (UNIQUE)
- `entries.title` (UNIQUE)
- `streaming_platforms.name` (UNIQUE)
- `genre_tags.name` (UNIQUE)

### Foreign Key Constraints

- `entries.creator_id` → `users.id` (ON DELETE SET NULL)
- `entries.platform_id` → `streaming_platforms.id` (ON DELETE SET NULL)
- `entry_tags.entry_id` → `entries.id` (ON DELETE CASCADE)
- `entry_tags.tag_id` → `genre_tags.id` (ON DELETE RESTRICT)
- `ratings.user_id` → `users.id` (ON DELETE SET NULL)
- `ratings.entry_id` → `entries.id` (ON DELETE CASCADE)

### Check Constraints

- `ratings.stars` CHECK (stars >= 1 AND stars <= 10)

### Application-Level Constraints

- Entry must have 1-3 genre tags (enforced by Zod validation)
- Only admin users can create/delete platforms and tags (enforced by command handlers)
- Cannot delete platform/tag if in use (checked in command handlers before deletion)
